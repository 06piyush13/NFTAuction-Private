declare const TypeId: unique symbol;
type TypeId = typeof TypeId;
declare const ConfigCompilationError_base: new <A extends Record<string, any>>(args: import("effect/Types").Simplify<A>) => import("effect/Cause").YieldableError & Record<typeof TypeId, typeof TypeId> & {
    readonly _tag: "ConfigCompilationError";
} & Readonly<A>;
/**
 * An error occurred while compiling the contract configuration file.
 *
 * @category errors
 */
export declare class ConfigCompilationError extends ConfigCompilationError_base<{
    /** A displayable message. */
    readonly message: string;
    /** An array of diagnostic messages from the TypeScript compiler. */
    readonly diagnostics: {
        messageText: string;
    }[];
}> {
}
/**
 * Determines if a value is a config compilation error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ConfigCompilationError}; `false` otherwise.
 *
 * @category guards
 */
export declare const isConfigCompilationError: (u: unknown) => u is ConfigCompilationError;
/**
 * Creates a new {@link ConfigCompilationError}.
 *
 * @category constructors
 */
export declare const make: (message: string, diagnostics: {
    messageText: string;
}[]) => ConfigCompilationError;
export {};
//# sourceMappingURL=ConfigCompilationError.d.ts.map