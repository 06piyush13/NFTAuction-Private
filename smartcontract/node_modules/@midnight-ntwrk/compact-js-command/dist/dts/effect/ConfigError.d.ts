declare const TypeId: unique symbol;
type TypeId = typeof TypeId;
declare const ConfigError_base: new <A extends Record<string, any>>(args: import("effect/Types").Simplify<A>) => import("effect/Cause").YieldableError & Record<typeof TypeId, typeof TypeId> & {
    readonly _tag: "ConfigError";
} & Readonly<A>;
/**
 * An error occurred while reading or processing the contract configuration file.
 *
 * @category errors
 */
export declare class ConfigError extends ConfigError_base<{
    /** A displayable message. */
    readonly message: string;
    /** Indicates a more specific cause of the error. */
    readonly cause?: unknown;
}> {
}
/**
 * Determines if a value is a configuration error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ConfigError}; `false` otherwise.
 *
 * @category guards
 */
export declare const isConfigError: (u: unknown) => u is ConfigError;
/**
 * Creates a new {@link ConfigError}.
 *
 * @category constructors
 */
export declare const make: (message: string, cause?: unknown) => ConfigError;
export {};
//# sourceMappingURL=ConfigError.d.ts.map