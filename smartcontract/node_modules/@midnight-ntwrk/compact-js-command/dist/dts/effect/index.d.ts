import { Command } from '@effect/cli';
export declare const deployCommand: Command.Command<"deploy", import("@effect/platform/Path").Path | import("@effect/platform/FileSystem").FileSystem | import("./ConfigCompiler.js").ConfigCompiler, import("./ConfigError.js").ConfigError | import("effect/ConfigError").ConfigError, {
    readonly args: string[];
} & {
    readonly signingKey: import("effect/Option").Option<string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"SigningKey">>;
    readonly outputFilePath: string;
    readonly outputPrivateStateFilePath: string;
    readonly outputZswapLocalStateFilePath: string;
} & {
    readonly config: string;
    readonly coinPublicKey: import("effect/Option").Option<(string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"CoinPublicKeyHex">) | (string & import("effect/Brand").Brand<"CoinPublicKeyBech32m">)>;
    readonly network: import("effect/Option").Option<string>;
}>;
export declare const circuitCommand: Command.Command<"circuit", import("@effect/platform/Path").Path | import("@effect/platform/FileSystem").FileSystem | import("./ConfigCompiler.js").ConfigCompiler, import("./ConfigError.js").ConfigError | import("effect/ConfigError").ConfigError, {
    readonly address: string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"ContractAddress">;
    readonly circuitId: string;
    readonly args: string[];
} & {
    readonly inputFilePath: string;
    readonly inputPrivateStateFilePath: string;
    readonly inputZswapLocalStateFilePath: import("effect/Option").Option<string>;
    readonly outputFilePath: string;
    readonly outputPrivateStateFilePath: string;
    readonly outputZswapLocalStateFilePath: string;
    readonly outputResultFilePath: string;
} & {
    readonly config: string;
    readonly coinPublicKey: import("effect/Option").Option<(string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"CoinPublicKeyHex">) | (string & import("effect/Brand").Brand<"CoinPublicKeyBech32m">)>;
    readonly network: import("effect/Option").Option<string>;
}>;
export declare const maintainCommand: Command.Command<"maintain", import("@effect/platform/Path").Path | import("@effect/platform/FileSystem").FileSystem | import("./ConfigCompiler.js").ConfigCompiler, import("./ConfigError.js").ConfigError | import("effect/ConfigError").ConfigError, {
    readonly subcommand: import("effect/Option").Option<({
        readonly newSigningKey: string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"SigningKey">;
        readonly address: string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"ContractAddress">;
    } & {
        readonly signingKey: import("effect/Option").Option<string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"SigningKey">>;
        readonly inputFilePath: string;
        readonly outputFilePath: string;
    } & {
        readonly config: string;
        readonly coinPublicKey: import("effect/Option").Option<(string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"CoinPublicKeyHex">) | (string & import("effect/Brand").Brand<"CoinPublicKeyBech32m">)>;
        readonly network: import("effect/Option").Option<string>;
    }) | ({
        readonly circuitId: string;
        readonly verifierKeyPath: import("effect/Option").Option<string>;
        readonly address: string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"ContractAddress">;
    } & {
        readonly signingKey: import("effect/Option").Option<string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"SigningKey">>;
        readonly inputFilePath: string;
        readonly outputFilePath: string;
    } & {
        readonly config: string;
        readonly coinPublicKey: import("effect/Option").Option<(string & import("effect/Brand").Brand<"PlainHex"> & import("effect/Brand").Brand<"CoinPublicKeyHex">) | (string & import("effect/Brand").Brand<"CoinPublicKeyBech32m">)>;
        readonly network: import("effect/Option").Option<string>;
    })>;
}>;
export * as CompiledContractReflection from './CompiledContractReflection.js';
export * as ConfigCompilationError from './ConfigCompilationError.js';
export * as ConfigCompiler from './ConfigCompiler.js';
export * as ConfigError from './ConfigError.js';
//# sourceMappingURL=index.d.ts.map