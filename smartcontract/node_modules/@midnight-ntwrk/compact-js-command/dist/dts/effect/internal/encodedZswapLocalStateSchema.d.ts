import * as Schema from 'effect/Schema';
export declare const EncodedCoinPublicKeySchema: Schema.Struct<{
    bytes: typeof Schema.Uint8Array;
}>;
export declare const EncodedContractAddressSchema: Schema.Struct<{
    bytes: typeof Schema.Uint8Array;
}>;
export declare const EncodedQualifiedShieldedCoinInfoSchema: Schema.Struct<{
    nonce: typeof Schema.Uint8Array;
    color: typeof Schema.Uint8Array;
    value: typeof Schema.BigInt;
    mt_index: typeof Schema.BigInt;
}>;
export declare const EncodedShieldedCoinInfoSchema: Schema.Struct<{
    nonce: typeof Schema.Uint8Array;
    color: typeof Schema.Uint8Array;
    value: typeof Schema.BigInt;
}>;
export declare const EncodedRecipientSchema: Schema.Struct<{
    is_left: typeof Schema.Boolean;
    left: Schema.Struct<{
        bytes: typeof Schema.Uint8Array;
    }>;
    right: Schema.Struct<{
        bytes: typeof Schema.Uint8Array;
    }>;
}>;
export declare const EncodedZswapLocalStateSchema: Schema.Struct<{
    coinPublicKey: Schema.Struct<{
        bytes: typeof Schema.Uint8Array;
    }>;
    currentIndex: typeof Schema.BigInt;
    inputs: Schema.Array$<Schema.Struct<{
        nonce: typeof Schema.Uint8Array;
        color: typeof Schema.Uint8Array;
        value: typeof Schema.BigInt;
        mt_index: typeof Schema.BigInt;
    }>>;
    outputs: Schema.Array$<Schema.Struct<{
        coinInfo: Schema.Struct<{
            nonce: typeof Schema.Uint8Array;
            color: typeof Schema.Uint8Array;
            value: typeof Schema.BigInt;
        }>;
        recipient: Schema.Struct<{
            is_left: typeof Schema.Boolean;
            left: Schema.Struct<{
                bytes: typeof Schema.Uint8Array;
            }>;
            right: Schema.Struct<{
                bytes: typeof Schema.Uint8Array;
            }>;
        }>;
    }>>;
}>;
export declare const encodeZswapLocalStateObject: (u: unknown, overrideOptions?: import("effect/SchemaAST").ParseOptions) => import("effect/Effect").Effect<{
    readonly coinPublicKey: {
        readonly bytes: readonly number[];
    };
    readonly currentIndex: string;
    readonly inputs: readonly {
        readonly value: string;
        readonly nonce: readonly number[];
        readonly color: readonly number[];
        readonly mt_index: string;
    }[];
    readonly outputs: readonly {
        readonly coinInfo: {
            readonly value: string;
            readonly nonce: readonly number[];
            readonly color: readonly number[];
        };
        readonly recipient: {
            readonly left: {
                readonly bytes: readonly number[];
            };
            readonly is_left: boolean;
            readonly right: {
                readonly bytes: readonly number[];
            };
        };
    }[];
}, import("effect/ParseResult").ParseError, never>;
export declare const decodeZswapLocalStateObject: (u: unknown, overrideOptions?: import("effect/SchemaAST").ParseOptions) => import("effect/Effect").Effect<{
    readonly coinPublicKey: {
        readonly bytes: Uint8Array<ArrayBufferLike>;
    };
    readonly currentIndex: bigint;
    readonly inputs: readonly {
        readonly value: bigint;
        readonly nonce: Uint8Array<ArrayBufferLike>;
        readonly color: Uint8Array<ArrayBufferLike>;
        readonly mt_index: bigint;
    }[];
    readonly outputs: readonly {
        readonly coinInfo: {
            readonly value: bigint;
            readonly nonce: Uint8Array<ArrayBufferLike>;
            readonly color: Uint8Array<ArrayBufferLike>;
        };
        readonly recipient: {
            readonly left: {
                readonly bytes: Uint8Array<ArrayBufferLike>;
            };
            readonly is_left: boolean;
            readonly right: {
                readonly bytes: Uint8Array<ArrayBufferLike>;
            };
        };
    }[];
}, import("effect/ParseResult").ParseError, never>;
//# sourceMappingURL=encodedZswapLocalStateSchema.d.ts.map