/*
 * This file is part of midnight-sdk.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { FileSystem, Path } from '@effect/platform';
import { Context, Effect, Layer, Option } from 'effect';
import { create } from 'ts-node';
import * as ConfigCompilationError from './ConfigCompilationError.js';
import * as ConfigError from './ConfigError.js';
/**
 * Compiles a contract configuration file into a JavaScript module.
 *
 * @category services
 */
export class ConfigCompiler extends Context.Tag('compact-js-command/ConfigCompiler')() {
}
/**
 * A {@link ConfigCompiler} implementation that uses TypeScript to compile the given file path and then load
 * it as a JavaScript module.
 *
 * @category layers
 */
export const layer = Layer.effect(ConfigCompiler, Effect.gen(function* () {
    const path = yield* Path.Path;
    const fs = yield* FileSystem.FileSystem;
    const getFilePathProperties = (filePath) => Effect.gen(function* () {
        const absoluteFilePath = path.resolve(filePath);
        const parsedAbsoluteFilePath = path.parse(absoluteFilePath);
        const absoluteFileImportPath = path.join(parsedAbsoluteFilePath.dir, `${parsedAbsoluteFilePath.name}.js`);
        const filePathModifiedTime = (yield* fs.stat(absoluteFilePath)).mtime;
        const fileImportPathModifiedTime = (yield* fs.exists(absoluteFileImportPath))
            ? (yield* fs.stat(absoluteFileImportPath)).mtime
            : Option.some(Option.getOrThrow(filePathModifiedTime));
        return {
            absoluteFilePath,
            absoluteWorkingDirectory: parsedAbsoluteFilePath.dir,
            absoluteFileImportPath,
            requiresCompilation: Option.getOrThrow(fileImportPathModifiedTime) <= Option.getOrThrow(filePathModifiedTime)
        };
    });
    const transpileTypeScript = ({ absoluteFilePath, absoluteFileImportPath, absoluteWorkingDirectory, requiresCompilation }) => Effect.gen(function* () {
        if (!requiresCompilation) {
            return absoluteFileImportPath;
        }
        try {
            const tsNodeService = create({ cwd: absoluteWorkingDirectory });
            yield* fs.writeFileString(absoluteFileImportPath, tsNodeService.compile(yield* fs.readFileString(absoluteFilePath), absoluteFilePath));
        }
        catch (err) { // eslint-disable-line @typescript-eslint/no-explicit-any
            return yield* err?.name === 'TSError'
                ? ConfigCompilationError.make('Failed to compile TypeScript configuration', err.diagnostics)
                : ConfigError.make('Unexpected error while compiling TypeScript configuration', err);
        }
        return absoluteFileImportPath;
    });
    return ConfigCompiler.of({
        compile: (filePath) => getFilePathProperties(filePath).pipe(Effect.flatMap(transpileTypeScript), Effect.flatMap((fileImportPath) => Effect.tryPromise(async () => ({
            moduleImportDirectoryPath: path.dirname(fileImportPath),
            module: await import(fileImportPath)
        }))), Effect.mapError((err) => ConfigError.make(`Error loading configuration '${filePath}'`, err)))
    });
}));
//# sourceMappingURL=ConfigCompiler.js.map