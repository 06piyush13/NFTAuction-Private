/*
 * This file is part of midnight-sdk.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { FileSystem, Path } from '@effect/platform';
import { CompiledContract, ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import * as Hex from '@midnight-ntwrk/platform-js/effect/Hex';
import { Effect, Either, identity, Layer } from 'effect';
import pkg from 'json5';
import TS from 'typescript';
const { parse, stringify } = pkg;
import { MidnightBech32m, UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import * as CompiledContractReflection from "../CompiledContractReflection.js";
const CONTRACT_FOLDER = 'contract';
const CONTRACT_DECLARATION_FILE = 'index.d.ts';
const TRUE_OR_FALSE_REGEXP = /^true|false$/;
class BasicHost {
    files;
    #files;
    constructor(files) {
        this.files = files;
        this.#files = { ...files };
    }
    getCurrentDirectory() {
        return '';
    }
    getDefaultLibFileName(_) {
        return 'lib';
    }
    getCompilationSettings() {
        return TS.getDefaultCompilerOptions();
    }
    getScriptVersion(fileName) {
        return String(this.files[fileName].version);
    }
    getScriptSnapshot(fileName) {
        return this.files[fileName]?.file;
    }
    getScriptFileNames() {
        return Object.keys(this.#files);
    }
    fileExists(path) {
        return !!this.files[path];
    }
    readFile(path) {
        const file = this.files[path].file;
        return file?.getText(0, file?.getLength());
    }
}
const parseBech32mToHex = (input) => Either.try({
    try: () => {
        const parsedBech32 = MidnightBech32m.parse(input);
        return UnshieldedAddress.codec.decode(parsedBech32.network, parsedBech32).hexString;
    },
    catch: (error) => error instanceof Error ? error : new Error(String(error))
});
const typeNodeName = (type) => {
    if (type.kind === TS.SyntaxKind.NumberKeyword)
        return 'number';
    if (type.kind === TS.SyntaxKind.BigIntKeyword)
        return 'bigint';
    if (type.kind === TS.SyntaxKind.StringKeyword)
        return 'string';
    if (type.kind === TS.SyntaxKind.BooleanKeyword)
        return 'boolean';
    if (type.kind === TS.SyntaxKind.ArrayType) {
        return `${typeNodeName(type.elementType)}[]`;
    }
    if (type.kind === TS.SyntaxKind.TupleType) {
        return `[${type.elements.map((_) => typeNodeName(_)).join(', ')}]`;
    }
    if (type.kind === TS.SyntaxKind.TypeLiteral) {
        const typeLiteral = type;
        return `{ ${typeLiteral.members.map((_) => `${_.name.escapedText.toString()}: ${typeNodeName(_.type)}`).join(', ')} }`;
    }
    if (type.kind === TS.SyntaxKind.TypeReference) {
        const typeName = type.typeName;
        if (TS.isIdentifier(typeName))
            return typeName.escapedText.toString();
    }
    return '<unknown>';
};
const transformParams = // eslint-disable-line @typescript-eslint/no-explicit-any
 (args, types, quotedStrings = false) => {
    if (args.length !== types.length) {
        return Either.left(ContractRuntimeError.make(`Invalid number of arguments. Expected ${types.length} arguments, but got ${args.length}`));
    }
    const transformedArgs = []; // eslint-disable-line @typescript-eslint/no-explicit-any
    for (let idx = 0; idx < types.length; idx++) {
        const type = types[idx];
        const transformedArg = Either.try({
            try: () => {
                if (type.kind === TS.SyntaxKind.NumberKeyword) {
                    return Number(args[idx]);
                }
                if (type.kind === TS.SyntaxKind.BigIntKeyword) {
                    return BigInt(args[idx]);
                }
                if (type.kind === TS.SyntaxKind.StringKeyword) {
                    return quotedStrings ? args[idx].replaceAll('\'', '') : args[idx];
                }
                if (type.kind === TS.SyntaxKind.BooleanKeyword) {
                    if (!TRUE_OR_FALSE_REGEXP.test(args[idx]))
                        throw new SyntaxError(`Cannot convert ${args[idx]} to a Boolean`);
                    return args[idx] === 'true';
                }
                if (type.kind === TS.SyntaxKind.ArrayType) {
                    const arrayElems = parse(args[idx]);
                    if (!Array.isArray(arrayElems)) {
                        throw new SyntaxError(`Cannot convert ${args[idx]} to an array`);
                    }
                    return Either.getOrThrowWith(transformParams(arrayElems.map((arrayElem) => stringify(arrayElem)), Array(arrayElems.length).fill(type.elementType), // Same type repeated.
                    true), identity // Rethrow the error from `transformParams`.
                    );
                }
                if (type.kind === TS.SyntaxKind.TupleType) {
                    const tupleElems = parse(args[idx]);
                    if (!Array.isArray(tupleElems)) {
                        throw new SyntaxError(`Cannot convert ${args[idx]} to an array`);
                    }
                    return Either.getOrThrowWith(transformParams(tupleElems.map((tupleElem) => stringify(tupleElem)), type.elements.map((elemType) => elemType), true), identity // Rethrow the error from `transformParams`.
                    );
                }
                if (type.kind === TS.SyntaxKind.TypeLiteral) {
                    const typeLiteral = type;
                    const srcObj = parse(args[idx]);
                    if (typeof srcObj !== 'object') {
                        throw new SyntaxError(`Cannot convert ${args[idx]} to an object literal`);
                    }
                    for (const member of typeLiteral.members) {
                        const propKey = member.name.escapedText.toString();
                        const propType = member.type;
                        const memberValue = Either.getOrThrowWith(transformParams([stringify(srcObj[propKey])], [propType], true), identity // Rethrow the error from `transformParams`.
                        );
                        srcObj[propKey] = memberValue[0];
                    }
                    return srcObj;
                }
                if (type.kind === TS.SyntaxKind.TypeReference) {
                    const typeName = type.typeName;
                    if (TS.isIdentifier(typeName) && typeName.escapedText === 'Uint8Array') {
                        const cleanInput = quotedStrings ? args[idx].replaceAll('\'', '') : args[idx];
                        const bech32Result = parseBech32mToHex(cleanInput);
                        const hexString = Either.match(bech32Result, {
                            onLeft: () => cleanInput,
                            onRight: (hex) => hex
                        });
                        return Either.match(Hex.parseHex(hexString), {
                            onRight: (parsedHex) => Buffer.from(parsedHex.byteChars, 'hex'),
                            onLeft: (parseErr) => {
                                throw new SyntaxError(`Cannot convert ${args[idx]} to a Uint8Array: ${parseErr.message}`);
                            }
                        });
                    }
                }
            },
            catch: (err) => ContractRuntimeError.make(`Failed to parse argument with index ${idx}`, ContractRuntimeError.make(`Failed to parse string '${args[idx]}' as type of ${typeNodeName(type)}`, err))
        });
        if (Either.isLeft(transformedArg))
            return transformedArg;
        transformedArgs.push(transformedArg.right);
    }
    return Either.right(transformedArgs);
};
const makeArgumentParser = (path, fs, baseAssetFolderPath) => (compiledContract) => Effect.gen(function* () {
    const assetsPath = CompiledContract.getCompiledAssetsPath(compiledContract);
    const tsDeclFilePath = path.join(path.resolve(baseAssetFolderPath, assetsPath), CONTRACT_FOLDER, CONTRACT_DECLARATION_FILE);
    const tsHost = new BasicHost({
        [tsDeclFilePath]: {
            file: TS.ScriptSnapshot.fromString(yield* fs.readFileString(tsDeclFilePath)),
            version: 1
        }
    });
    const tsLangService = TS.createLanguageService(tsHost, TS.createDocumentRegistry());
    const sourceFile = tsLangService.getProgram().getSourceFile(tsDeclFilePath);
    const impureCircuitsTypeNode = sourceFile?.statements.find((_) => TS.isTypeAliasDeclaration(_)
        && _.name.escapedText === 'ImpureCircuits'
        && _.type.kind === TS.SyntaxKind.TypeLiteral);
    const circuitMethodSignatureNodes = impureCircuitsTypeNode.type.members;
    const contractClassNode = sourceFile?.statements.find((_) => TS.isClassDeclaration(_) && _.name.escapedText === 'Contract');
    const initialStateMethodSignatureNode = contractClassNode.members.find((_) => TS.isMethodDeclaration(_)
        && _.name.escapedText === 'initialState');
    return {
        parseInitializationArgs: (args) => transformParams(args, initialStateMethodSignatureNode.parameters.slice(1).map((_) => _.type)),
        parseCircuitArgs: (circuitId, args) => {
            const circuitNode = circuitMethodSignatureNodes.find((_) => _.name.escapedText === circuitId);
            if (!circuitNode) {
                return Either.left(ContractRuntimeError.make(`Circuit '${circuitId}' not found on the Compact generated TypeScript declaration.`));
            }
            return transformParams(args, circuitNode.parameters.slice(1).map((_) => _.type));
        }
    };
});
export const layer = (baseAssetFolderPath = '.') => Layer.effect(CompiledContractReflection.CompiledContractReflection, Effect.gen(function* () {
    const path = yield* Path.Path;
    const fs = yield* FileSystem.FileSystem;
    return CompiledContractReflection.CompiledContractReflection.of({
        createArgumentParser: makeArgumentParser(path, fs, baseAssetFolderPath)
    });
}));
//# sourceMappingURL=compiledContractReflection.js.map