'use strict';

var midnightJsTypes = require('@midnight-ntwrk/midnight-js-types');
var crossFetch = require('cross-fetch');

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The name of the path containing proving and verifying keys.
 */
const KEY_PATH = 'keys';
/**
 * File extension for proving keys.
 */
const PROVER_EXT = '.prover';
/**
 * File extension for verifying keys.
 */
const VERIFIER_EXT = '.verifier';
/**
 * The name of the path containing zkIRs.
 */
const ZKIR_PATH = 'zkir';
/**
 * File extension for zkIRs.
 */
const ZKIR_EXT = '.bzkir';
/**
 * Retrieves ZK artifacts from a remote source.
 */
class FetchZkConfigProvider extends midnightJsTypes.ZKConfigProvider {
    baseURL;
    fetchFunc;
    /**
     * @param baseURL The endpoint to query for ZK artifacts.
     * @param fetchFunc The function to use to execute queries.
     */
    constructor(baseURL, fetchFunc = crossFetch.fetch) {
        super();
        this.baseURL = baseURL;
        this.fetchFunc = fetchFunc;
        const urlObject = new URL(baseURL);
        if (urlObject.protocol !== 'http:' && urlObject.protocol !== 'https:') {
            throw new midnightJsTypes.InvalidProtocolSchemeError(urlObject.protocol, ['http:', 'https:']);
        }
    }
    async sendRequest(url, circuitId, ext, responseType) {
        const response = await this.fetchFunc(`${this.baseURL}/${url}/${circuitId}${ext}`, {
            method: 'GET'
        });
        if (response.ok) {
            // The compiler can't infer that this return value is well-typed, so I cast to 'any'
            /* eslint-disable @typescript-eslint/no-explicit-any */
            return responseType === 'text'
                ? (await response.text())
                : (await response.arrayBuffer().then((arrayBuffer) => new Uint8Array(arrayBuffer)));
            /* eslint-enable @typescript-eslint/no-explicit-any */
        }
        throw new Error(response.statusText);
    }
    getProverKey(circuitId) {
        return this.sendRequest(KEY_PATH, circuitId, PROVER_EXT, 'arraybuffer').then(midnightJsTypes.createProverKey);
    }
    getVerifierKey(circuitId) {
        return this.sendRequest(KEY_PATH, circuitId, VERIFIER_EXT, 'arraybuffer').then(midnightJsTypes.createVerifierKey);
    }
    getZKIR(circuitId) {
        return this.sendRequest(ZKIR_PATH, circuitId, ZKIR_EXT, 'arraybuffer').then(midnightJsTypes.createZKIR);
    }
}

exports.FetchZkConfigProvider = FetchZkConfigProvider;
//# sourceMappingURL=index.cjs.map
